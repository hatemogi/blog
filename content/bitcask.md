---
layout: default
title: Bitcask 소개
---

목표: Bitcask가 얼마나 간단한 KV스토어인지 안내. 간단한 매력으로 써볼만하다는점을 강조.


[Bitcask](https://github.com/basho/bitcask/)는 로컬 파일시스템에 데이타를 저장하는 키-값(Key-Value) 보관소입니다. [Riak](http://www.basho.com/products_riak_overview.php)이라는 확장성 뛰어난 키-값 저장소에서 개별 노드의 로컬 시스템에 키-값을 저장할 때 기본으로 쓰는 오픈소스 라이브러리입니다. 

문서를 살펴보니, 그 간단한 구조와 추구하는 바가 마음에 들어 조금 깊이 살펴보기로 했습니다. 비슷하게 로컬 파일시스템에 라이브러리 형태로 키-값을 저장해 사용하는 오픈소스 프로젝트로 [Tokyo Cabinet](http://fallabs.com/tokyocabinet/), [Berkley DB](http://www.oracle.com/technetwork/database/berkeleydb/overview/index.html), [LevelDB](http://code.google.com/p/leveldb/) 등이 있습니다만, Bitcask는 그 중 유독 간단한 구조로 되어있습니다. 대신 상대적으로 기능이 제한적이라고 할 수 있습니다만, 쓰고자 하는 필요한 기능이 Bitcask가 제공하는 기능 범위 안에서 충분하다면, 만족스럽게 써볼만한 라이브러리입니다. 

[Bitcask에 대해 간단히 안내한 블로그 글](http://blog.basho.com/2010/04/27/hello-bitcask/)에는 다음과 같은 요구사항을 언급하고 있습니다.

* 아이템을 읽거나 쓸 때 지연시간이 짧아야한다.
* 빠른 처리속도. 특히, 계속해서 입력되는 아이템을 저장하기에도 빨라야 한다. 
* RAM 용량 보다 훨씬 큰 데이타셋도 속도저하 없이 처리할 수 있어야 한다. 
* 크래쉬에 대응할 수 있어야한다. 복구 시간이 빨라야하고, 데이타 손실도 없어야한다. 
* 백업과 복구가 편해야한다. 
* 상대적으로 간단하고 이해하기 쉬운 (그래서 지원하기 편한) 코드 구조와 데이타 포맷을 써야한다.
* 부하가 높을 때나 대규모 용량을 처리하는 데에도 예측할 수 있는 동작을 해야한다.
* Riak에서 기본으로 사용할 수 있는 라이센스여야 한다.
 
Riak을 만든 Basho에서는, 위와 같은 요구사항들을 모두 만족하는 기존 제품을 고려하다가, Bitcask를 직접 만들어서 사용하기로 한 것이죠. 가장 큰 특징으로는 모든 키(Key)의 인덱스(index)를 메모리에 해쉬테이블로 관리하면서, 이 테이블에서 찾은 파일 오프셋을 보고 해당 데이터 파일을 읽어서 원하는 값(Value)을 찾는 구조라는 점입니다. 성격은 조금 다르게 볼 수 있습니다만, [Redis](http://redis.io)의 경우 모든 키-값을 다 메모리에 올려놓고 사용하는 방식이고, 다른 일반적인 로컬 키-값 보관소는 파일기반으로 몇 번을 검색하는 방식일텐데, Bitcask의 경우는 모든 키의 인덱스 테이블은 모두 메모리에 올려놓고, 그 인덱스에서 알아낸 위치를 보고 파일에서 해당 값을 한번에 읽어오는 방식입니다. 따라서, 읽기/쓰기 모두 한번씩의 파일접근만으로 처리할 수 있으므로, 더 빠르게 처리할 수 있다는 장점이 있습니다. 

이어서, [Bitcask 디자인을 설명한 문서(pdf)](http://downloads.basho.com/papers/bitcask-intro.pdf)의 내용을 조금 더 자세히 옮겨서 정리해보겠습니다. 

Bitcask 인스턴스
------------

한 Bitcask 인스턴스는 하나의 디렉토리입니다. 그리고, 동시에 단 하나의 운영체제(OS) 프로세스만이 인스턴스에 쓸 수 있다는 제약이 있습니다. 그 하나의 프로세스가 데이타베이스 서버 역할을 한다고 생각해도 됩니다. 한순간에는 디렉토리 안에 하나의 active 파일만이 쓰기에 활용되고, 해당 파일이 어떤 한계크기에 이르면 닫기고, 새로운 active 파일이 만들어져 사용됩니다. 의도적으로 닫거나 서버의 종료 때문에 닫기거나 두 경우 모두 한번 닫긴 파일의 내용은 바뀌지 않습니다. 그리고, 다시 쓰기모드로 열리지도 않습니다. 

[그림 1]






